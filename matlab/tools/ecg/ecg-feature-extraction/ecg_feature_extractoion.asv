function [ecg_features_vector, ecg_feature_names, ecg_features_units, exit_flag] = ecg_feature_extractoion(data, fs, f_notch, n_eigenvalues)
% all_features_vector = extract_ecg_features_one_record(signal_name, data, fs, n_eigenvalues, n_features, f_notch)
% Description: Extract features from one record of ECG signal
%
% INPUT:
% data - ECG signal as matrix CxT which C indicates number of ECG channels (in microvolts).
% fs   - Sampling frequency of the ECG signal (in Hz).
% f_notch - Frequency for the notch filter (in Hz).
% n_eigenvalues - Number of eigenvalues for SVD features (scaler).
%
% DEPENDENCIES:
% 1. peak_det_likelihood function from the OSET package
% 2. peak_det_likelihood_long_recs function from the OSET package
% 3. fiducial_det_lsim function from the OSET package
%
% OUTPUT: 
% ecg_features_vector - includes the following features per each channel:
%   1. SNR features (2)
%   2. HRV features (7)
%   3. Features related to time interval (29)
%   4. Features related to amplitude and area under curve (32)
%   5. Features related to angle (12)
%   6. Complexity analysis features (2)
%   7. SVD features (default 10)
% ecg_feature_names - name of features for one channel
% exit_flag - with 0 indicates successful, and minus values (-K)
% indicates error in processing K channels out of C channels

% Author: Seyedeh Somayyeh Mousavi
% Date: Jan 11, 2025
% Author: Sajjad Karimi
% Date: Mar 10, 2025
% Location: Emory University, Georgia, USA
% Email: bmemousavi@gmail.com

if nargin<3
    f_notch = 50;
end

if nargin<4
    n_eigenvalues = 10;
end

% Define ECG-related features
ecg_feature_names = {
    'SNR_median', 'SNR_mean', 'N_beats', 'RMSSD', 'SDNN', 'HR_median', 'HR_mean', 'HR_upper_5', 'HR_lower_5', ...
    'mean_pr_interval_TI', 'std_pr_interval_TI', 'median_pr_interval_TI', 'mean_qt_interval_TI', 'std_qt_interval_TI', 'median_qt_interval_TI', 'QTc_b','QTc_f' ...
    'mean_st_Se_TI', 'std_st_Se_TI', 'median_st_Se_TI', 'mean_pr_Se_TI', 'std_pr_Se_TI', 'median_pr_Se_TI', ...
    'mean_pr_peaks_TI', 'std_pr_peaks_TI', 'median_pr_peaks_TI', 'mean_qr_peaks_TI', 'std_qr_peaks_TI', 'median_qr_peaks_TI', ...
    'mean_qrs_complex_TI', 'std_qrs_complex_TI', 'median_qrs_complex_TI', ...
    'mean_rs_peaks_TI', 'std_rs_peaks_TI', 'median_rs_peaks_TI', 'mean_rt_peaks_TI', 'std_rt_peaks_TI', 'median_rt_peaks_TI', ...
    'mean_qrs_A', 'std_qrs_A', 'median_qrs_A', 'mean_qrs_area', 'std_qrs_area', 'median_qrs_area', 'mean_qrs_abs_area', 'std_qrs_abs_area', 'median_qrs_abs_area', ...
    'mean_t_A', 'std_t_A', 'median_t_A', 'ratio_qrs_t_A', 'mean_t_area', 'std_t_area', 'median_t_area',  'mean_t_abs_area', 'std_t_abs_area', 'median_t_abs_area', ...
    'mean_p_A', 'std_p_A', 'median_p_A', 'ratio_qrs_p_A', 'mean_p_area', 'std_p_area', 'median_p_area', 'mean_p_abs_area', 'std_p_abs_area', 'median_p_abs_area', ...
    'mean_st_Se_A', 'std_st_Se_A', 'median_st_Se_A', ...
    'mean_pr_angles', 'std_pr_angles', 'median_pr_angles', ...
    'mean_qr_angles', 'std_qr_angles', 'median_qr_angles', ...
    'mean_rs_angles', 'std_rs_angles', 'median_rs_angles', ...
    'mean_rt_angles', 'std_rt_angles', 'median_rt_angles' , ...
    'mobility', 'complexity'};

% Define corresponding units for ECG features
ecg_features_units = {
    'db', 'db', 'scaler', 'ms', 'ms', 'bpm', 'bpm', 'bpm', 'bpm',...
    'ms', 'ms', 'ms', 'ms', 'ms', 'ms','ms', 'ms', ...
    'ms', 'ms', 'ms', 'ms', 'ms', 'ms', ...
    'ms', 'ms', 'ms', 'ms', 'ms', 'ms', ...
    'ms', 'ms', 'ms', ...
    'ms', 'ms', 'ms', 'ms', 'ms', 'ms', ...
    'mv', 'mv', 'mv', 'mv*ms', 'mv*ms', 'mv*ms', 'mv*ms', 'mv*ms', 'mv*ms', ...
    'mv', 'mv', 'mv', 'scaler', 'mv*ms', 'mv*ms', 'mv*ms', 'mv*ms', 'mv*ms', 'mv*ms',...
    'mv', 'mv', 'mv', 'scaler', 'mv*ms', 'mv*ms', 'mv*ms', 'mv*ms', 'mv*ms', 'mv*ms',...
    'mv', 'mv', 'mv',...
    'deg', 'deg', 'deg', 'deg', 'deg', 'deg', ...
    'deg', 'deg', 'deg', 'deg', 'deg', 'deg', ...
    'scaler', 'scaler'};

exit_flag = 0;
% n_features = 2 + 7 + 29 + 32 + 12 + 2 + n_eigenvalues;
n_features = length(ecg_feature_names) + n_eigenvalues; % per channel

for n = 1:n_eigenvalues
    ecg_feature_names{end+1} = ['svd', num2str(n_eigenvalues)];
    ecg_features_units{end+1} = 'scaler';
end

%% Data Preprocessing
n_channels = size(data, 1);
Q = 40;  % Quality factor for notch filter
low_pass_fre = 0.1;
high_pass_fre = min(fs/2-1, 100); % 100 Hz if fs>200Hz

% Design the notch filter
[b, a] = iirnotch(f_notch/(fs/2), f_notch/(fs/2)/Q);

% Apply Low and High Pass filter
data = data - lp_filter_zero_phase(data, low_pass_fre/fs);
data = lp_filter_zero_phase(data, high_pass_fre/fs);

% Apply the notch filter to the signal
data = filter(b, a, data, [], 2);

%% Feature Extraction
ecg_features_vector = [];
for j = 1:n_channels

    data_channel = data(j, :);
    try
        % Detect peaks based on recording length
        if (size(data, 2)/fs) < 90.0
            [~, R_peaks_indexes] = peak_det_likelihood(data_channel, fs);
        else
            [~, R_peaks_indexes] = peak_det_likelihood_long_recs(data_channel, fs);
        end

        % Run ECG fiducial points detector
        % position = fiducial_det_lsim(data_channel, R_peaks_indexes, fs);
        % Run wavedet_3D
        % heasig.nsig = 1;
        % heasig.freq = fs;
        % heasig.nsamp = length(data_channel);
        % [position, ~, ~] = wavedet_3D(data_channel', R_peaks_indexes, heasig);

        flag_post_processing = 1;
        position = fiducial_det_lsim( data_channel', R_peaks_indexes, fs, flag_post_processing);


        % Extract features
        snr_features = ecg_snr_features(data_channel, R_peaks_indexes);
        hrv_features = ecg_hrv_features(R_peaks_indexes, fs);
        ti_features = ecg_time_intervals_features(R_peaks_indexes, position, fs);
        amps_areas_features = ecg_area_amp_features(data_channel, position, fs);
        angles_features = ecg_angles_features(data_channel, position, fs);
        complexity_analysis_features = ecg_complexity_features(data_channel);
        svd_features = ecg_svd_features(data_channel, R_peaks_indexes, n_eigenvalues);

        % Convert feature structures to arrays
        snr_features = struct2array(snr_features);
        hrv_features = struct2array(hrv_features);
        ti_features = struct2array(ti_features);
        amps_areas_features = struct2array(amps_areas_features);
        angles_features = struct2array(angles_features);
        complexity_features= struct2array(complexity_analysis_features);
        % svd_features = struct2array(svd_features);

        % Concatenate extracted features into a single vector
        all_features = [snr_features, hrv_features, ti_features, amps_areas_features, angles_features, complexity_features, svd_features];

        % Append to the overall feature vector
        ecg_features_vector = cat(2, ecg_features_vector, all_features);

    catch ME
        % Error handling: display message and set NaN values for problematic channel
        disp(ME.message);
        fprintf("Error in processing signal_channel: %s, %d\n", j);
        ecg_features_vector = cat(2, ecg_features_vector, nan(1, n_features));
        exit_flag = exit_flag -1;

    end
end


end
